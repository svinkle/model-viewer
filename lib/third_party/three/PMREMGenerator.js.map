{"version":3,"file":"PMREMGenerator.js","sourceRoot":"","sources":["../../../src/third_party/three/PMREMGenerator.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @author Prashant Sharma / spidersharma03\n * @author Ben Houston / bhouston, https://clara.io\n *\n * To avoid cube map seams, I create an extra pixel around each face. This way when the cube map is\n * sampled by an application later(with a little care by sampling the centre of the texel), the extra 1 border\n *\tof pixels makes sure that there is no seams artifacts present. This works perfectly for cubeUV format as\n *\twell where the 6 faces can be arranged in any manner whatsoever.\n * Code in the beginning of fragment shader's main function does this job for a given resolution.\n *\tRun Scene_PMREM_Test.html in the examples directory to see the sampling from the cube lods generated\n *\tby this class.\n */\n\nimport * as THREE from 'three';\n\nexport default ( function () {\n\n\tvar shader = getShader();\n\tvar camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0.0, 1000 );\n\tvar scene = new THREE.Scene();\n\tvar planeMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2, 0 ), shader );\n\tplaneMesh.material.side = THREE.DoubleSide;\n\tscene.add( planeMesh );\n\tscene.add( camera );\n\n\tvar PMREMGenerator = function ( sourceTexture, samplesPerLevel, resolution ) {\n\n\t\tthis.sourceTexture = sourceTexture;\n\t\tthis.resolution = ( resolution !== undefined ) ? resolution : 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons\n\t\tthis.samplesPerLevel = ( samplesPerLevel !== undefined ) ? samplesPerLevel : 32;\n\n\t\tvar monotonicEncoding = ( this.sourceTexture.encoding === THREE.LinearEncoding ) ||\n\t\t\t( this.sourceTexture.encoding === THREE.GammaEncoding ) || ( this.sourceTexture.encoding === THREE.sRGBEncoding );\n\n\t\tthis.sourceTexture.minFilter = ( monotonicEncoding ) ? THREE.LinearFilter : THREE.NearestFilter;\n\t\tthis.sourceTexture.magFilter = ( monotonicEncoding ) ? THREE.LinearFilter : THREE.NearestFilter;\n\t\tthis.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;\n\n\t\tthis.cubeLods = [];\n\n\t\tvar size = this.resolution;\n\t\tvar params = {\n\t\t\tformat: this.sourceTexture.format,\n\t\t\tmagFilter: this.sourceTexture.magFilter,\n\t\t\tminFilter: this.sourceTexture.minFilter,\n\t\t\ttype: this.sourceTexture.type,\n\t\t\tgenerateMipmaps: this.sourceTexture.generateMipmaps,\n\t\t\tanisotropy: this.sourceTexture.anisotropy,\n\t\t\tencoding: this.sourceTexture.encoding\n\t\t};\n\n\t\t// how many LODs fit in the given CubeUV Texture.\n\t\tthis.numLods = Math.log( size ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2\n\n\t\tfor ( var i = 0; i < this.numLods; i ++ ) {\n\n\t\t\tvar renderTarget = new THREE.WebGLRenderTargetCube( size, size, params );\n\t\t\trenderTarget.texture.name = \"PMREMGenerator.cube\" + i;\n\t\t\tthis.cubeLods.push( renderTarget );\n\t\t\tsize = Math.max( 16, size / 2 );\n\n\t\t}\n\n\t};\n\n\tPMREMGenerator.prototype = {\n\n\t\tconstructor: PMREMGenerator,\n\n\t\t/*\n\t\t * Prashant Sharma / spidersharma03: More thought and work is needed here.\n\t\t * Right now it's a kind of a hack to use the previously convolved map to convolve the current one.\n\t\t * I tried to use the original map to convolve all the lods, but for many textures(specially the high frequency)\n\t\t * even a high number of samples(1024) dosen't lead to satisfactory results.\n\t\t * By using the previous convolved maps, a lower number of samples are generally sufficient(right now 32, which\n\t\t * gives okay results unless we see the reflection very carefully, or zoom in too much), however the math\n\t\t * goes wrong as the distribution function tries to sample a larger area than what it should be. So I simply scaled\n\t\t * the roughness by 0.9(totally empirical) to try to visually match the original result.\n\t\t * The condition \"if(i <5)\" is also an attemt to make the result match the original result.\n\t\t * This method requires the most amount of thinking I guess. Here is a paper which we could try to implement in future::\n\t\t * https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html\n\t\t */\n\t\tupdate: function ( renderer ) {\n\n\t\t\t// Texture should only be flipped for CubeTexture, not for\n\t\t\t// a Texture created via THREE.WebGLRenderTargetCube.\n\t\t\tvar tFlip = ( this.sourceTexture.isCubeTexture ) ? - 1 : 1;\n\n\t\t\tshader.defines[ 'SAMPLES_PER_LEVEL' ] = this.samplesPerLevel;\n\t\t\tshader.uniforms[ 'faceIndex' ].value = 0;\n\t\t\tshader.uniforms[ 'envMap' ].value = this.sourceTexture;\n\t\t\tshader.envMap = this.sourceTexture;\n\t\t\tshader.needsUpdate = true;\n\n\t\t\tvar gammaInput = renderer.gammaInput;\n\t\t\tvar gammaOutput = renderer.gammaOutput;\n\t\t\tvar toneMapping = renderer.toneMapping;\n\t\t\tvar toneMappingExposure = renderer.toneMappingExposure;\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\trenderer.toneMappingExposure = 1.0;\n\t\t\trenderer.gammaInput = false;\n\t\t\trenderer.gammaOutput = false;\n\n\t\t\tfor ( var i = 0; i < this.numLods; i ++ ) {\n\n\t\t\t\tvar r = i / ( this.numLods - 1 );\n\t\t\t\tshader.uniforms[ 'roughness' ].value = r * 0.9; // see comment above, pragmatic choice\n\t\t\t\t// Only apply the tFlip for the first LOD\n\t\t\t\tshader.uniforms[ 'tFlip' ].value = ( i == 0 ) ? tFlip : 1;\n\t\t\t\tvar size = this.cubeLods[ i ].width;\n\t\t\t\tshader.uniforms[ 'mapSize' ].value = size;\n\t\t\t\tthis.renderToCubeMapTarget( renderer, this.cubeLods[ i ] );\n\n\t\t\t\tif ( i < 5 ) shader.uniforms[ 'envMap' ].value = this.cubeLods[ i ].texture;\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\t\trenderer.toneMapping = toneMapping;\n\t\t\trenderer.toneMappingExposure = toneMappingExposure;\n\t\t\trenderer.gammaInput = gammaInput;\n\t\t\trenderer.gammaOutput = gammaOutput;\n\n\t\t},\n\n\t\trenderToCubeMapTarget: function ( renderer, renderTarget ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis.renderToCubeMapTargetFace( renderer, renderTarget, i );\n\n\t\t\t}\n\n\t\t},\n\n\t\trenderToCubeMapTargetFace: function ( renderer, renderTarget, faceIndex ) {\n\n\t\t\trenderTarget.activeCubeFace = faceIndex;\n\t\t\tshader.uniforms[ 'faceIndex' ].value = faceIndex;\n\t\t\trenderer.render( scene, camera, renderTarget, true );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tfor ( var i = 0, l = this.cubeLods.length; i < l; i ++ ) {\n\n\t\t\t\tthis.cubeLods[ i ].dispose();\n\n\t\t\t}\n\n\t\t},\n\n\t};\n\n\tfunction getShader() {\n\n\t\tvar shaderMaterial = new THREE.ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t\"SAMPLES_PER_LEVEL\": 20,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"faceIndex\": { value: 0 },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"mapSize\": { value: 0.5 },\n\t\t\t\t\"envMap\": { value: null },\n\t\t\t\t\"tFlip\": { value: - 1 },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"#include <common>\\n\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform int faceIndex;\\n\\\n\t\t\t\tuniform float roughness;\\n\\\n\t\t\t\tuniform samplerCube envMap;\\n\\\n\t\t\t\tuniform float mapSize;\\n\\\n\t\t\t\tuniform float tFlip;\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\\n\t\t\t\t\tfloat a = ggxRoughness + 0.0001;\\n\\\n\t\t\t\t\ta *= a;\\n\\\n\t\t\t\t\treturn ( 2.0 / a - 2.0 );\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\\n\\\n\t\t\t\t\tfloat phi = uv.y * 2.0 * PI;\\n\\\n\t\t\t\t\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\\n\\\n\t\t\t\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n\t\t\t\t\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\\n\\\n\t\t\t\t\treturn vecSpace * sampleDir;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\\n\\\n\t\t\t\t{\\n\\\n\t\t\t\t\tfloat a = Roughness * Roughness;\\n\\\n\t\t\t\t\tfloat Phi = 2.0 * PI * uv.x;\\n\\\n\t\t\t\t\tfloat CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\\n\\\n\t\t\t\t\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\\n\\\n\t\t\t\t\treturn vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tmat3 matrixFromVector(vec3 n) {\\n\\\n\t\t\t\t\tfloat a = 1.0 / (1.0 + n.z);\\n\\\n\t\t\t\t\tfloat b = -n.x * n.y * a;\\n\\\n\t\t\t\t\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\\n\\\n\t\t\t\t\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\\n\\\n\t\t\t\t\treturn mat3(b1, b2, n);\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvec4 testColorMap(float Roughness) {\\n\\\n\t\t\t\t\tvec4 color;\\n\\\n\t\t\t\t\tif(faceIndex == 0)\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 1)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 2)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,0.0,1.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 3)\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,1.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 4)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,1.0,1.0);\\n\\\n\t\t\t\t\telse\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,1.0,1.0);\\n\\\n\t\t\t\t\tcolor *= ( 1.0 - Roughness );\\n\\\n\t\t\t\t\treturn color;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec3 sampleDirection;\\n\\\n\t\t\t\t\tvec2 uv = vUv*2.0 - 1.0;\\n\\\n\t\t\t\t\tfloat offset = -1.0/mapSize;\\n\\\n\t\t\t\t\tconst float a = -1.0;\\n\\\n\t\t\t\t\tconst float b = 1.0;\\n\\\n\t\t\t\t\tfloat c = -1.0 + offset;\\n\\\n\t\t\t\t\tfloat d = 1.0 - offset;\\n\\\n\t\t\t\t\tfloat bminusa = b - a;\\n\\\n\t\t\t\t\tuv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\\n\\\n\t\t\t\t\tuv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\\n\\\n\t\t\t\t\tif (faceIndex==0) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(1.0, -uv.y, -uv.x);\\n\\\n\t\t\t\t\t} else if (faceIndex==1) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(-1.0, -uv.y, uv.x);\\n\\\n\t\t\t\t\t} else if (faceIndex==2) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, 1.0, uv.y);\\n\\\n\t\t\t\t\t} else if (faceIndex==3) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -1.0, -uv.y);\\n\\\n\t\t\t\t\t} else if (faceIndex==4) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -uv.y, 1.0);\\n\\\n\t\t\t\t\t} else {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(-uv.x, -uv.y, -1.0);\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\t\t\tvec3 correctedDirection = vec3( tFlip * sampleDirection.x, sampleDirection.yz );\\n\\\n\t\t\t\t\tmat3 vecSpace = matrixFromVector( normalize( correctedDirection ) );\\n\\\n\t\t\t\t\tvec3 rgbColor = vec3(0.0);\\n\\\n\t\t\t\t\tconst int NumSamples = SAMPLES_PER_LEVEL;\\n\\\n\t\t\t\t\tvec3 vect;\\n\\\n\t\t\t\t\tfloat weight = 0.0;\\n\\\n\t\t\t\t\tfor( int i = 0; i < NumSamples; i ++ ) {\\n\\\n\t\t\t\t\t\tfloat sini = sin(float(i));\\n\\\n\t\t\t\t\t\tfloat cosi = cos(float(i));\\n\\\n\t\t\t\t\t\tfloat r = rand(vec2(sini, cosi));\\n\\\n\t\t\t\t\t\tvect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\\n\\\n\t\t\t\t\t\tfloat dotProd = dot(vect, normalize(sampleDirection));\\n\\\n\t\t\t\t\t\tweight += dotProd;\\n\\\n\t\t\t\t\t\tvec3 color = envMapTexelToLinear(textureCube(envMap, vect)).rgb;\\n\\\n\t\t\t\t\t\trgbColor.rgb += color;\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\t\t\trgbColor /= float(NumSamples);\\n\\\n\t\t\t\t\t//rgbColor = testColorMap( roughness ).rgb;\\n\\\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\\n\\\n\t\t\t\t}\",\n\n\t\t\tblending: THREE.NoBlending\n\n\t\t} );\n\n\t\tshaderMaterial.type = 'PMREMGenerator';\n\n\t\treturn shaderMaterial;\n\n\t}\n\n\treturn PMREMGenerator;\n\n} )();\n"]}