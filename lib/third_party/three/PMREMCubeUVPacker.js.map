{"version":3,"file":"PMREMCubeUVPacker.js","sourceRoot":"","sources":["../../../src/third_party/three/PMREMCubeUVPacker.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @author Prashant Sharma / spidersharma03\n * @author Ben Houston / bhouston, https://clara.io\n *\n * This class takes the cube lods(corresponding to different roughness values), and creates a single cubeUV\n * Texture. The format for a given roughness set of faces is simply::\n * +X+Y+Z\n * -X-Y-Z\n * For every roughness a mip map chain is also saved, which is essential to remove the texture artifacts due to\n * minification.\n * Right now for every face a PlaneMesh is drawn, which leads to a lot of geometry draw calls, but can be replaced\n * later by drawing a single buffer and by sending the appropriate faceIndex via vertex attributes.\n * The arrangement of the faces is fixed, as assuming this arrangement, the sampling function has been written.\n */\n\nimport * as THREE from 'three';\n\nexport default ( function () {\n\n\tvar camera = new THREE.OrthographicCamera();\n\tvar scene = new THREE.Scene();\n\tvar shader = getShader();\n\n\tvar PMREMCubeUVPacker = function ( cubeTextureLods ) {\n\n\t\tthis.cubeLods = cubeTextureLods;\n\t\tvar size = cubeTextureLods[ 0 ].width * 4;\n\n\t\tvar sourceTexture = cubeTextureLods[ 0 ].texture;\n\t\tvar params = {\n\t\t\tformat: sourceTexture.format,\n\t\t\tmagFilter: sourceTexture.magFilter,\n\t\t\tminFilter: sourceTexture.minFilter,\n\t\t\ttype: sourceTexture.type,\n\t\t\tgenerateMipmaps: sourceTexture.generateMipmaps,\n\t\t\tanisotropy: sourceTexture.anisotropy,\n\t\t\tencoding: ( sourceTexture.encoding === THREE.RGBEEncoding ) ? THREE.RGBM16Encoding : sourceTexture.encoding\n\t\t};\n\n\t\tif ( params.encoding === THREE.RGBM16Encoding ) {\n\n\t\t\tparams.magFilter = THREE.LinearFilter;\n\t\t\tparams.minFilter = THREE.LinearFilter;\n\n\t\t}\n\n\t\tthis.CubeUVRenderTarget = new THREE.WebGLRenderTarget( size, size, params );\n\t\tthis.CubeUVRenderTarget.texture.name = \"PMREMCubeUVPacker.cubeUv\";\n\t\tthis.CubeUVRenderTarget.texture.mapping = THREE.CubeUVReflectionMapping;\n\n\t\tthis.objects = [];\n\n\t\tvar geometry = new THREE.PlaneBufferGeometry( 1, 1 );\n\n\t\tvar faceOffsets = [];\n\t\tfaceOffsets.push( new THREE.Vector2( 0, 0 ) );\n\t\tfaceOffsets.push( new THREE.Vector2( 1, 0 ) );\n\t\tfaceOffsets.push( new THREE.Vector2( 2, 0 ) );\n\t\tfaceOffsets.push( new THREE.Vector2( 0, 1 ) );\n\t\tfaceOffsets.push( new THREE.Vector2( 1, 1 ) );\n\t\tfaceOffsets.push( new THREE.Vector2( 2, 1 ) );\n\n\t\tvar textureResolution = size;\n\t\tsize = cubeTextureLods[ 0 ].width;\n\n\t\tvar offset2 = 0;\n\t\tvar c = 4.0;\n\t\tthis.numLods = Math.log( cubeTextureLods[ 0 ].width ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2\n\t\tfor ( var i = 0; i < this.numLods; i ++ ) {\n\n\t\t\tvar offset1 = ( textureResolution - textureResolution / c ) * 0.5;\n\t\t\tif ( size > 16 ) c *= 2;\n\t\t\tvar nMips = size > 16 ? 6 : 1;\n\t\t\tvar mipOffsetX = 0;\n\t\t\tvar mipOffsetY = 0;\n\t\t\tvar mipSize = size;\n\n\t\t\tfor ( var j = 0; j < nMips; j ++ ) {\n\n\t\t\t\t// Mip Maps\n\t\t\t\tfor ( var k = 0; k < 6; k ++ ) {\n\n\t\t\t\t\t// 6 Cube Faces\n\t\t\t\t\tvar material = shader.clone();\n\t\t\t\t\tmaterial.uniforms[ 'envMap' ].value = this.cubeLods[ i ].texture;\n\t\t\t\t\tmaterial.envMap = this.cubeLods[ i ].texture;\n\t\t\t\t\tmaterial.uniforms[ 'faceIndex' ].value = k;\n\t\t\t\t\tmaterial.uniforms[ 'mapSize' ].value = mipSize;\n\n\t\t\t\t\tvar planeMesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tplaneMesh.position.x = faceOffsets[ k ].x * mipSize - offset1 + mipOffsetX;\n\t\t\t\t\tplaneMesh.position.y = faceOffsets[ k ].y * mipSize - offset1 + offset2 + mipOffsetY;\n\t\t\t\t\tplaneMesh.material.side = THREE.BackSide;\n\t\t\t\t\tplaneMesh.scale.setScalar( mipSize );\n\t\t\t\t\tthis.objects.push( planeMesh );\n\n\t\t\t\t}\n\t\t\t\tmipOffsetY += 1.75 * mipSize;\n\t\t\t\tmipOffsetX += 1.25 * mipSize;\n\t\t\t\tmipSize /= 2;\n\n\t\t\t}\n\t\t\toffset2 += 2 * size;\n\t\t\tif ( size > 16 ) size /= 2;\n\n\t\t}\n\n\t};\n\n\tPMREMCubeUVPacker.prototype = {\n\n\t\tconstructor: PMREMCubeUVPacker,\n\n\t\tupdate: function ( renderer ) {\n\n\t\t\tvar size = this.cubeLods[ 0 ].width * 4;\n\t\t\t// top and bottom are swapped for some reason?\n\t\t\tcamera.left = - size * 0.5;\n\t\t\tcamera.right = size * 0.5;\n\t\t\tcamera.top = - size * 0.5;\n\t\t\tcamera.bottom = size * 0.5;\n\t\t\tcamera.near = 0;\n\t\t\tcamera.far = 1;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tfor ( var i = 0; i < this.objects.length; i ++ ) {\n\n\t\t\t\tscene.add( this.objects[ i ] );\n\n\t\t\t}\n\n\t\t\tvar gammaInput = renderer.gammaInput;\n\t\t\tvar gammaOutput = renderer.gammaOutput;\n\t\t\tvar toneMapping = renderer.toneMapping;\n\t\t\tvar toneMappingExposure = renderer.toneMappingExposure;\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\trenderer.gammaInput = false;\n\t\t\trenderer.gammaOutput = false;\n\t\t\trenderer.toneMapping = THREE.LinearToneMapping;\n\t\t\trenderer.toneMappingExposure = 1.0;\n\t\t\trenderer.render( scene, camera, this.CubeUVRenderTarget, false );\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\t\trenderer.toneMapping = toneMapping;\n\t\t\trenderer.toneMappingExposure = toneMappingExposure;\n\t\t\trenderer.gammaInput = gammaInput;\n\t\t\trenderer.gammaOutput = gammaOutput;\n\n\t\t\tfor ( var i = 0; i < this.objects.length; i ++ ) {\n\n\t\t\t\tscene.remove( this.objects[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tfor ( var i = 0, l = this.objects.length; i < l; i ++ ) {\n\n\t\t\t\tthis.objects[ i ].material.dispose();\n\n\t\t\t}\n\n\t\t\tthis.objects[ 0 ].geometry.dispose();\n\n\t\t}\n\n\t};\n\n\tfunction getShader() {\n\n\t\tvar shaderMaterial = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t\"faceIndex\": { value: 0 },\n\t\t\t\t\"mapSize\": { value: 0 },\n\t\t\t\t\"envMap\": { value: null },\n\t\t\t\t\"testColor\": { value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n        \"precision highp float;\\\n        varying vec2 vUv;\\\n        void main() {\\\n          vUv = uv;\\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\n        }\",\n\n\t\t\tfragmentShader:\n        \"precision highp float;\\\n        varying vec2 vUv;\\\n        uniform samplerCube envMap;\\\n        uniform float mapSize;\\\n        uniform vec3 testColor;\\\n        uniform int faceIndex;\\\n        \\\n        void main() {\\\n          vec3 sampleDirection;\\\n          vec2 uv = vUv;\\\n          uv = uv * 2.0 - 1.0;\\\n          uv.y *= -1.0;\\\n          if(faceIndex == 0) {\\\n            sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\\\n          } else if(faceIndex == 1) {\\\n            sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\\\n          } else if(faceIndex == 2) {\\\n            sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\\\n          } else if(faceIndex == 3) {\\\n            sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\\\n          } else if(faceIndex == 4) {\\\n            sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\\\n          } else {\\\n            sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\\\n          }\\\n          vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\\\n          gl_FragColor = linearToOutputTexel( color );\\\n        }\",\n\n\t\t\tblending: THREE.NoBlending\n\n\t\t} );\n\n\t\tshaderMaterial.type = 'PMREMCubeUVPacker';\n\n\t\treturn shaderMaterial;\n\n\t}\n\n\n\treturn PMREMCubeUVPacker;\n\n} )();\n"]}